#lang racket
(define-syntax match
  (syntax-rules (else guard)
    ((_ v) (error 'match "~s" v))
    ((_ v (else e ...)) (begin e ...))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (begin e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (begin e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (equal? v (quote lit)) kt kf))))
(define (target-fixnum? x)
  (and (integer? x)
       (exact? x)
       (<= (- (expt 2 60)) x (- (expt 2 60) 1))))
(define (datum? x)
  (or (null? x) (boolean? x) (target-fixnum? x)
      (and (pair? x) (datum? (car x)) (datum? (cdr x)))
      (and (vector? x)
           (let ((len (vector-length x)))
             (let loop ((i 0))
               (cond ((= len i) #t)
                     ((datum? (vector-ref x i)) (loop (+ i 1)))
                     (else #f)))))))
(define (compose2 f g)
  (lambda (x)
    (f (g x))))
(define-syntax compose
  (syntax-rules ()
    ((_ f) f)
    ((_ f g) (compose2 f g))
    ((_ f g ...) (compose2 f (compose g ...)))))
(define counter
  (let ((n 0))
    (lambda ()
      (set! n (+ n 1))
      n)))
(define (unique-symbol x)
  (string->symbol
   (format "~a.~s" x (counter))))
(define (Quote d)
  (list 'quote d))
(define (If q a e)
  (list 'if q a e))
(define (Lambda x* body)
  (list 'lambda x* body))
(define (Set! x e)
  (list 'set! x e))
(define (Begin exps)
  (cons 'begin exps))
(define (sep bds k)
  (k (map car bds) (map cadr bds)))
(define (Let x* e* body)
  (list 'let (map list x* e*) body))
(define (Letrec x* e* body)
  (list 'letrec (map list x* e*) body))
(define (set? x)
  (cond ((null? x) #t)
        ((memq (car x) (cdr x)) #f)
        (else (set? (cdr x)))))
(define (set-cons x s)
  (if (memq x s)
      s
      (cons x s)))
(define (U s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (U (cdr s1) s2))
        (else (cons (car s1) (U (cdr s1) s2)))))
(define (I s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (cons (car s1) (I (cdr s1) s2)))
        (else (I (cdr s1) s2))))
(define (D s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (D (cdr s1) s2))
        (else (cons (car s1) (D (cdr s1) s2)))))
(define prims
  '(+ - * = < > <= >= null? fixnum? boolean? procedure? pair? vector? box? eq? not
      cons car cdr set-car! set-cdr! box unbox set-box! make-vector vector-length
      vector-ref vector-set! void))
(define (prim? x)
  (memq x prims))
(define (parse-scheme x)
  (define prim-env
    '((+ . +)
      (- . -)
      (* . *)
      (= . =)
      (< . <)
      (> . >)
      (<= . <=)
      (>= . >=)
      (null? . null?)
      (fixnum? . fixnum?)
      (boolean? . boolean?)
      (procedure? . procedure?)
      (pair? . pair?)
      (vector? . vector?)
      (box? . box?)
      (eq? . eq?)
      (not . not)
      (cons . cons)
      (car . car)
      (cdr . cdr)
      (set-car! . set-car!)
      (set-cdr! . set-cdr!)
      (box . box)
      (unbox . unbox)
      (set-box! . set-box!)
      (make-vector . make-vector)
      (vector-length . vector-length)
      (vector-ref . vector-ref)
      (vector-set! . vector-set!)
      (void . void)))
  (define (make-body exps env)
    (cond ((null? exps) (error 'parse-scheme "empty begin body"))
          ((null? (cdr exps)) ((parse0 env) (car exps)))
          (else (Begin (map (parse0 env) exps)))))
  (define (parse0 env)
    (lambda (exp)
      (match exp
        (,n (guard (number? n)) (if (target-fixnum? n)
                                    (Quote n)
                                    (error 'parse-scheme "invalid number ~s" n)))
        (,b (guard (boolean? b)) (Quote b))
        (,x (guard (symbol? x)) (cond ((assq x env) => cdr)
                                      (else (error 'parse-scheme "unbound variable ~s" x))))
        ((,rator . ,rands) (if (symbol? rator)
                               (let ((a (assq rator env)))
                                 (if a
                                     (let ((rator (cdr a))
                                           (rands (map (parse0 env) rands)))
                                       (if (eq? rator 'not)
                                           (If (car rands) (Quote #f) (Quote #t))
                                           (cons rator rands)))
                                     ((parse1 env) exp)))
                               (map (parse0 env) exp)))
        (else (error 'parse-scheme "invalid input ~s" exp)))))
  (define (parse1 env)
    (lambda (exp)
      (match exp
        ((quote ,d) (if (datum? d)
                        exp
                        (error 'parse-scheme "invalid datum ~s" d)))
        ((if ,q ,a) (If ((parse0 env) q)
                        ((parse0 env) a)
                        '(void)))
        ((if ,q ,a ,e) (If ((parse0 env) q)
                           ((parse0 env) a)
                           ((parse0 env) e)))
        ((set! ,x ,e) (let ((x (cond ((assq x env) => cdr)
                                     (else (error 'parse-scheme "can't assign to unbound variable ~s" x)))))
                        (Set! x ((parse0 env) e))))
        ((begin . ,exps) (make-body exps env))
        ((and . ,exps) (if (null? exps)
                           (Quote #t)
                           (let ((exps (map (parse0 env) exps)))
                             (let loop ((exp (car exps)) (exps (cdr exps)))
                               (if (null? exps)
                                   exp
                                   (If exp (loop (car exps) (cdr exps)) (Quote #f)))))))
        ((or . ,exps) (if (null? exps)
                          (Quote #f)
                          (let ((exps (map (parse0 env) exps)))
                            (let loop ((exp (car exps)) (exps (cdr exps)))
                              (if (null? exps)
                                  exp
                                  (let ((u (unique-symbol 't)))
                                    `(let ((,u ,exp))
                                       (if ,u ,u ,(loop (car exps) (cdr exps))))))))))
        ((lambda ,x* . ,exps)
         (unless (set? x*)
           (error 'parse-scheme "invalid formals ~s" x*))
         (let* ((x*^ (map unique-symbol x*))
                (env (append (map cons x* x*^) env)))
           (Lambda x*^ (make-body exps env))))
        ((let ,bds . ,exps)
         (sep bds
              (lambda (x* e*)
                (unless (set? x*)
                  (error 'parse-scheme "invalid let LHS vars ~s" x*))
                (let* ((x*^ (map unique-symbol x*))
                       (env^ (append (map cons x* x*^) env))
                       (e* (map (parse0 env) e*))
                       (body (make-body exps env^)))
                  (Let x*^ e* body)))))
        ((letrec ,bds . ,exps)
         (sep bds
              (lambda (x* e*)
                (unless (set? x*)
                  (error 'parse-scheme "invalid letrec LHS vars ~s" x*))
                (let* ((x*^ (map unique-symbol x*))
                       (env^ (append (map cons x* x*^) env))
                       (e* (map (parse0 env^) e*))
                       (body (make-body exps env^)))
                  (Letrec x*^ e* body)))))
        (else (error 'parse-scheme "unbound variable ~s" (car exp))))))
  ((parse0 prim-env) x))
(define (convert-complex-datum x)
  (define (convert-datum x)
    (cond ((pair? x) (list 'cons (convert-datum (car x)) (convert-datum (cdr x))))
          ((vector? x)
           (let ((l (vector-length x)))
             (if (= l 0)
                 '(make-vector '0)
                 (let ((u (unique-symbol 't)))
                   `(let ((,u (make-vector (quote ,l))))
                      ,(let loop ((i l) (e* (cons u '())))
                         (if (= i 0)
                             (cons 'begin e*)
                             (let ((i (- i 1)))
                               (loop i
                                     (cons
                                      `(vector-set! ,u (quote ,i) ,(convert-datum (vector-ref x i)))
                                      e*))))))))))
          (else (Quote x))))
  (define global-bindings '())
  (define (convert exp)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (let ((u (unique-symbol 't)))
                        (set! global-bindings (cons (list u (convert-datum d)) global-bindings))
                        u)
                      exp))
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) (If (convert q) (convert a) (convert e)))
      ((set! ,x ,e) (Set! x (convert e)))
      ((begin . ,exps) (Begin (map convert exps)))
      ((lambda ,x* ,body) (Lambda x* (convert body)))
      ((let ,bds ,body)
       (sep bds
            (lambda (x* e*)
              (let ((e* (map convert e*))
                    (body (convert body)))
                (Let x* e* body)))))
      ((letrec ,bds ,body)
       (sep bds
            (lambda (x* e*)
              (let ((e* (map convert e*))
                    (body (convert body)))
                (Letrec x* e* body)))))
      (else (map convert exp))))
  (let ((x (convert x)))
    (if (null? global-bindings)
        x
        `(let ,global-bindings ,x))))
(define test
  (compose pretty-print convert-complex-datum parse-scheme))
(define test-code0
  '((let ((if (lambda (x y z) z)))
      (if #t 0 1))
    (let ((not (lambda (x) (not x))))
      (not 1))
    (and 1 2 3 4 5)
    (or 1 2 3 4 5)
    (lambda (x)
      (lambda (y)
        (lambda (z)
          ((x y) z))))
    (letrec ((even? (lambda (n)
                      (if (= n 0)
                          #t
                          (odd? (- n 1)))))
             (odd? (lambda (n)
                     (if (= n 0)
                         #f
                         (even? (- n 1))))))
      (even? 8))
    (let ((n 0))
      (letrec ((even? (lambda ()
                        (if (= n 0)
                            #t
                            (begin (set! n (- n 1))
                                   (odd?)))))
               (odd? (lambda ()
                       (if (= n 0)
                           #f
                           (begin (set! n (- n 1))
                                  (even?))))))
        (set! n 8)
        (even?)))
    (let ((not (lambda (x) (not x))))
      (not 10))
    (let ((if (lambda (x y z) (if x y z)))
          (not (lambda (x) (not x))))
      (not if))
    (let ((lambda (lambda (x y) (eq? x y)))
          (f (lambda () 10)))
      (lambda (f) 10))))
(define test-code1
  '((let ((x '(1 2 3))
          (y '#(#() #(1 2 3) #(#t #f))))
      (cons x (cons y '())))
    '#(#() #(1 2) (1 2) (#t #f #(1 2)))))
(define (test-all test-code)
  (for-each test test-code))
