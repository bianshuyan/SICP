#lang racket
(require racket/fixnum)
(define-syntax match
  (syntax-rules (else guard)
    ((_ v) (error 'match "~s" v))
    ((_ v (else e ...)) (begin e ...))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (begin e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (begin e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (eq? v (quote lit)) kt kf))))
(define (target-fixnum? x)
  (and (integer? x)
       (exact? x)
       (<= (- (expt 2 60)) x (- (expt 2 60) 1))))
(define (datum? x)
  (or (null? x) (boolean? x) (target-fixnum? x)
      (and (pair? x) (datum? (car x)) (datum? (cdr x)))
      (and (vector? x)
           (let ((len (vector-length x)))
             (let loop ((i 0))
               (cond ((= len i) #t)
                     ((datum? (vector-ref x i)) (loop (+ i 1)))
                     (else #f)))))))
(define (compose2 f g)
  (lambda (x)
    (f (g x))))
(define-syntax compose
  (syntax-rules ()
    ((_ f) f)
    ((_ f g ...) (compose2 f (compose g ...)))))
(define counter
  (let ((n 0))
    (lambda ()
      (set! n (+ n 1))
      n)))
(define (unique-symbol x)
  (string->symbol
   (format "~a.~s" x (counter))))
(define (unique-label x)
  (string->symbol
   (format "~a$~s" x (counter))))
(define label?
  (lambda (x)
    (and (symbol? x)
         (let* ([s (symbol->string x)] [n (string-length s)])
           (define (s0 i)
             (and (not (fx= i -1))
                  (cond
                    [(char<=? #\0 (string-ref s i) #\9) (s1 (fx- i 1))]
                    [else #f])))
           (define (s1 i)
             (and (not (fx= i -1))
                  (let ([c (string-ref s i)])
                    (cond
                      [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                      [(char=? c #\$) #t]
                      [(char=? c #\0) (s2 (fx- i 1))]
                      [else #f]))))
           (define (s2 i)
             (and (not (fx= i -1))
                  (let ([c (string-ref s i)])
                    (cond
                      [(char<=? #\1 (string-ref s i) #\9) (s1 (fx- i 1))]
                      [(char=? c #\0) (s2 (fx- i 1))]
                      [else #f]))))
           (s0 (fx- n 1))))))
(define (set? x)
  (cond ((null? x) #t)
        ((memq (car x) (cdr x)) #f)
        (else (set? (cdr x)))))
(define (set-cons x s)
  (if (memq x s)
      s
      (cons x s)))
(define (U s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (U (cdr s1) s2))
        (else (cons (car s1) (U (cdr s1) s2)))))
(define (I s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (cons (car s1) (I (cdr s1) s2)))
        (else (I (cdr s1) s2))))
(define (D s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (D (cdr s1) s2))
        (else (cons (car s1) (D (cdr s1) s2)))))
(define (make-begin exps)
  (define (flatten exp)
    (match exp
      ((begin . ,exps) (apply append (map flatten exps)))
      (else (list exp))))
  (let ((exps (apply append (map flatten exps))))
    (if (null? (cdr exps))
        (car exps)
        (cons 'begin exps))))
(define (: bds k)
  (k (map car bds) (map cadr bds)))
(define (Let x* e* body)
  (list 'let (map list x* e*) body))
(define (Letrec x* e* body)
  (list 'letrec (map list x* e*) body))
(define prims
  '(+ - * = < > <= >= null? fixnum? boolean? procedure? pair? vector? box? eq? not
      cons car cdr set-car! set-cdr! box unbox set-box! make-vector vector-length
      vector-ref vector-set! void))
(define (prim? x)
  (memq x prims))
(define (parse-scheme x)
  (define prim-env
    '((+ . +)
      (- . -)
      (* . *)
      (= . =)
      (< . <)
      (> . >)
      (<= . <=)
      (>= . >=)
      (null? . null?)
      (fixnum? . fixnum?)
      (boolean? . boolean?)
      (procedure? . procedure?)
      (pair? . pair?)
      (vector? . vector?)
      (box? . box?)
      (eq? . eq?)
      (not . not)
      (cons . cons)
      (car . car)
      (cdr . cdr)
      (set-car! . set-car!)
      (set-cdr! . set-cdr!)
      (box . box)
      (unbox . unbox)
      (set-box! . set-box!)
      (make-vector . make-vector)
      (vector-length . vector-length)
      (vector-ref . vector-ref)
      (vector-set! . vector-set!)
      (void . void)))
  (define (lookup var env)
    (cond ((assq var env) => cdr)
          (else (error 'parse-scheme "unbound variable ~s" var))))
  (define (make-body exps env)
    (cond ((null? exps) (error 'parse-scheme "empty begin body"))
          ((null? (cdr exps)) ((parse env) (car exps)))
          (else (cons 'begin (map (parse env) exps)))))
  (define (parse env)
    (lambda (exp)
      (match exp
        (,n (guard (number? n)) (if (target-fixnum? n)
                                    `(quote ,n)
                                    (error 'parse-scheme "invalid number ~s" n)))
        (,b (guard (boolean? b)) `(quote ,b))
        (,x (guard (symbol? x)) (lookup x env))
        ((,rator . ,rands) (if (symbol? rator)
                               (let ((a (assq rator env)))
                                 (if a
                                     (let ((rator (cdr a))
                                           (rands (map (parse env) rands)))
                                       (if (eq? rator 'not)
                                           `(if ,(car rands) '#f '#t)
                                           (cons rator rands)))
                                     ((parse-form env) exp)))
                               (map (parse env) exp)))
        (else (error 'parse-scheme "invalid input ~s" exp)))))
  (define (parse-form env)
    (lambda (exp)
      (match exp
        ((quote ,d) (if (datum? d)
                        exp
                        (error 'parse-scheme "invalid datum ~s" d)))
        ((if ,q ,a) `(if ,((parse env) q) ,((parse env) a) (void)))
        ((if ,q ,a ,e) `(if ,((parse env) q) ,((parse env) a) ,((parse env) e)))
        ((set! ,x ,e) `(set! ,(lookup x env) ,((parse env) e)))
        ((begin . ,exps) (make-body exps env))
        ((and . ,exps) (if (null? exps)
                           ''#t
                           (let ((exps (map (parse env) exps)))
                             (let loop ((exp (car exps)) (exps (cdr exps)))
                               (if (null? exps)
                                   exp
                                   `(if ,exp ,(loop (car exps) (cdr exps)) '#f))))))
        ((or . ,exps) (if (null? exps)
                          ''#f
                          (let ((exps (map (parse env) exps)))
                            (let loop ((exp (car exps)) (exps (cdr exps)))
                              (if (null? exps)
                                  exp
                                  (let ((t (unique-symbol 't)))
                                    `(let ((,t ,exp))
                                       (if ,t ,t ,(loop (car exps) (cdr exps))))))))))
        ((lambda ,x* . ,exps)
         (unless (set? x*)
           (error 'parse-scheme "invalid formals ~s" x*))
         (let* ((x*^ (map unique-symbol x*))
                (env (append (map cons x* x*^) env))
                (body (make-body exps env)))
           `(lambda ,x*^ ,body)))
        ((let ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid let LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env) e*))
                     (body (make-body exps env^)))
                (Let x*^ e* body)))))
        ((letrec ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid letrec LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env^) e*))
                     (body (make-body exps env^)))
                (Letrec x*^ e* body)))))
        (else (error 'parse-scheme "unbound variable ~s" (car exp))))))
  ((parse prim-env) x))
(define (convert-complex-datum x)
  (define (convert-datum x)
    (cond ((pair? x) (list 'cons (convert-datum (car x)) (convert-datum (cdr x))))
          ((vector? x)
           (let ((l (vector-length x)))
             (if (= l 0)
                 '(make-vector '0)
                 (let ((t (unique-symbol 't)))
                   `(let ((,t (make-vector (quote ,l))))
                      ,(let loop ((i l) (e* (cons t '())))
                         (if (= i 0)
                             (cons 'begin e*)
                             (let ((i (- i 1)))
                               (loop i
                                     (cons
                                      `(vector-set! ,t (quote ,i) ,(convert-datum (vector-ref x i)))
                                      e*))))))))))
          (else `(quote ,x))))
  (define bindings '())
  (define (convert exp)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (let ((t (unique-symbol 't)))
                        (set! bindings (cons (list t (convert-datum d)) bindings))
                        t)
                      exp))
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(convert q) ,(convert a) ,(convert e)))
      ((begin . ,exps) (cons 'begin (map convert exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(convert body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Letrec x* e* body)))))
      (else (map convert exp))))
  (let ((x (convert x)))
    (if (null? bindings)
        x
        `(let ,bindings ,x))))
(define (uncover-assigned x)
  (define (uncover-exps exps)
    (if (null? exps)
        (values '() '())
        (let-values (((a u*0) (uncover (car exps)))
                     ((d u*1) (uncover-exps (cdr exps))))
          (values (cons a d) (U u*0 u*1)))))
  (define (uncover exp)
    (match exp
      ((quote ,d) (values exp '()))
      (,x (guard (symbol? x)) (values x '()))
      ((if ,q ,a ,e) (let-values (((q u*0) (uncover q))
                                  ((a u*1) (uncover a))
                                  ((e u*2) (uncover e)))
                       (values `(if ,q ,a ,e) (U (U u*0 u*1) u*2))))
      ((set! ,x ,e) (let-values (((e u*) (uncover e)))
                      (values `(set! ,x ,e) (set-cons x u*))))
      ((begin . ,exps) (let-values (((exps u*) (uncover-exps exps)))
                         (values (cons 'begin exps) u*)))
      ((lambda ,x* ,body) (let-values (((body u*) (uncover body)))
                            (values `(lambda ,x*
                                       (assigned ,(I x* u*) ,body))
                                    (D u* x*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (values (Let x* e* `(assigned ,(I x* u*1) ,body))
                      (U u*0 (D u*1 x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (let ((u*2 (U u*0 u*1)))
                (values (Letrec x* e* `(assigned ,(I x* u*2) ,body))
                        (D u*2 x*)))))))
      (else (uncover-exps exp))))
  (let-values (((x u*) (uncover x)))
    (if (null? u*)
        x
        (error 'uncover-assigned "unbound assigned variables ~s" u*))))
(define (purify-letrec x)
  (define (Let x* e* a* body)
    (if (null? x*)
        body
        (list 'let (map list x* e*) `(assigned ,a* ,body))))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        (list 'letrec (map list x* e*) body)))
  (define (purify exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(purify q) ,(purify a) ,(purify e)))
      ((set! ,x ,e) `(set! ,x ,(purify e)))
      ((begin . ,exps) (cons 'begin (map purify exps)))
      ((lambda ,x* (assigned ,a* ,body))
       `(lambda ,x* (assigned ,a* ,(purify body))))
      ((let ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (Let x* e* a* body)))))
      ((letrec ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body))
                  (lambda? (lambda (x) (and (pair? x) (eq? (car x) 'lambda))))
                  (bound? (lambda (x) (memq x x*)))
                  (assigned? (lambda (x) (memq x a*))))
              (define (simple? e)
                (match e
                  ((quote ,d) #t)
                  (,x (guard (symbol? x)) (not (bound? x)))
                  ((,prim . ,rands) (guard (prim? prim)) (andmap simple? rands))
                  (else #f)))
              (let loop ((x* x*) (e* e*) (xs* '()) (es* '()) (xl* '()) (el* '()) (xc* '()) (ec* '()))
                (if (null? x*)
                    (Let xs* es* '()
                         (Let xc* (make-list (length xc*) '(void)) xc*
                              (Letrec xl* el*
                                      (let ((xt* (map (lambda (xc) (unique-symbol 't)) xc*)))
                                        (Let xt* ec* '()
                                             `(begin ,@(map (lambda (xc xt) `(set! ,xc ,xt)) xc* xt*)
                                                     ,body))))))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (assigned? x)
                          (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))
                          (if (lambda? e)
                              (loop x* e* xs* es* (cons x xl*) (cons e el*) xc* ec*)
                              (if (simple? e)
                                  (loop x* e* (cons x xs*) (cons e es*) xl* el* xc* ec*)
                                  (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))))))))))))
      (else (map purify exp))))
  (purify x))
(define (convert-assignments x)
  (define (Let x* e* body)
    (if (null? x*)
        body
        (list 'let (map list x* e*) body)))
  (define (convert env)
    (lambda (exp)
      (match exp
        ((quote ,d) exp)
        (,x (guard (symbol? x)) (if (memq x env) `(unbox ,x) x))
        ((if ,q ,a ,e) `(if ,((convert env) q) ,((convert env) a) ,((convert env) e)))
        ((set! ,x ,e) `(set-box! ,x ,((convert env) e)))
        ((begin . ,exps) (cons 'begin (map (convert env) exps)))
        ((lambda ,x* (assigned ,a* ,body))
         (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                (bds (map cons a* t*))
                (lookup (lambda (x)
                          (cond ((assq x bds) => cdr)
                                (else x))))
                (x*^ (map lookup x*))
                (e* (map (lambda (t) `(box ,t)) t*)))
           `(lambda ,x*^
              ,(Let a* e* ((convert (append a* env)) body)))))
        ((let ,bds (assigned ,a* ,body))
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert (append a* env)) body)))
                (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                       (bds (map cons a* t*))
                       (lookup (lambda (x)
                                 (cond ((assq x bds) => cdr)
                                       (else x))))
                       (x*^ (map lookup x*))
                       (e*^ (map (lambda (t) `(box ,t)) t*)))
                  (Let x*^ e* (Let a* e*^ body)))))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert env) body)))
                (Letrec x* e* body)))))
        (else (map (convert env) exp)))))
  ((convert '()) x))
(define (optimize-direct-call x)
  (define (optimize exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(optimize q) ,(optimize a) ,(optimize e)))
      ((begin . ,exps) (cons 'begin (map optimize exps)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map optimize e*))
                  (body (optimize body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map optimize e*))
                  (body (optimize body)))
              (Letrec x* e* body)))))
      (((lambda ,x* ,body) . ,e*)
       (let ((e* (map optimize e*))
             (body (optimize body)))
         (Let x* e* body)))
      (else (map optimize exp))))
  (optimize x))
(define (remove-anonymous-lambda x)
  (define (remove exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(remove q) ,(remove a) ,(remove e)))
      ((begin . ,exps) (cons 'begin (map remove exps)))
      ((lambda ,x* ,body) (let ((t (unique-symbol 't)))
                            `(letrec ((,t (lambda ,x* ,(remove body)))) ,t)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body)))
                               (else (remove e)))) e*))
                  (body (remove body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body))))) e*))
                  (body (remove body)))
              (Letrec x* e* body)))))
      (else (map remove exp))))
  (remove x))
(define (sanitize-binding-forms x)
  (define (Let x* e* body)
    (if (null? x*)
        body
        (list 'let (map list x* e*) body)))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        (list 'letrec (map list x* e*) body)))
  (define (sanitize exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(sanitize q) ,(sanitize a) ,(sanitize e)))
      ((begin . ,exps) (make-begin (map sanitize exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(sanitize body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (let loop ((x* x*) (e* e*) (xo* '()) (eo* '()) (xl* '()) (el* '()))
                (if (null? x*)
                    (Letrec xl* el* (Let xo* eo* body))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (and (pair? e) (eq? (car e) 'lambda))
                          (loop x* e* xo* eo* (cons x xl*) (cons e el*))
                          (loop x* e* (cons x xo*) (cons e eo*) xl* el*)))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (Letrec x* e* body)))))
      (else (map sanitize exp))))
  (sanitize x))
(define compile0
  (compose sanitize-binding-forms
           remove-anonymous-lambda
           optimize-direct-call
           convert-assignments
           purify-letrec
           uncover-assigned
           convert-complex-datum
           parse-scheme))
(define (uncover-free x)
  (define (uncover-exps exps)
    (if (null? exps)
        (values '() '())
        (let-values (((a f*0) (uncover (car exps)))
                     ((d f*1) (uncover-exps (cdr exps))))
          (values (cons a d) (U f*0 f*1)))))
  (define (uncover exp)
    (match exp
      ((quote ,d) (values exp '()))
      (,x (guard (symbol? x)) (values x (if (prim? x) '() (list x))))
      ((if ,q ,a ,e) (let-values (((q f*0) (uncover q))
                                  ((a f*1) (uncover a))
                                  ((e f*2) (uncover e)))
                       (values `(if ,q ,a ,e) (U f*0 (U f*1 f*2)))))
      ((begin . ,exps) (let-values (((exps f*) (uncover-exps exps)))
                         (values (cons 'begin exps) f*)))
      ((lambda ,x* ,body) (let-values (((body f*) (uncover body)))
                            (let ((f* (D f* x*)))
                              (values `(lambda ,x* (free ,f* ,body)) f*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* f*0) (uncover-exps e*))
                         ((body f*1) (uncover body)))
              (values (Let x* e* body) (U f*0 (D f*1 x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* f*0) (uncover-exps e*))
                         ((body f*1) (uncover body)))
              (values (Letrec x* e* body) (D (U f*0 f*1) x*))))))
      (else (uncover-exps exp))))
  (let-values (((x f*) (uncover x)))
    (if (null? f*)
        x
        (error 'uncover-free "uncaptured free variables ~s" f*))))
(define (convert-closures x)
  (define (convert exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(convert q) ,(convert a) ,(convert e)))
      ((begin . ,exps) (cons 'begin (map convert exps)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((l* (map (lambda (x) (unique-label 'l)) x*))
                  (cp* (map (lambda (x) (unique-symbol 'cp)) x*)))
              (let ((e* (map (lambda (e cp)
                               (match e
                                 ((lambda ,x* (free ,f* ,body))
                                  `(lambda ,(cons cp x*) (free ,f* ,(convert body)))))) e* cp*))
                    (f** (map (lambda (e)
                                (match e
                                  ((lambda ,x* (free ,f* ,body)) f*))) e*)))
                (Letrec l* e*
                        `(closures ,(map list x* l* f**) ,(convert body))))))))
      (else (let ((exp (map convert exp)))
              (let ((rator (car exp)) (rands (cdr exp)))
                (if (symbol? rator)
                    (if (prim? rator)
                        (cons rator rands)
                        (cons rator (cons rator rands)))
                    (let ((t (unique-symbol 't)))
                      `(let ((,t ,rator))
                         (,t ,t . ,rands)))))))))
  (convert x))
(define (optimize-known-call x)
  (define (optimize env)
    (lambda (exp)
      (match exp
        ((quote ,d) exp)
        (,x (guard (symbol? x)) x)
        ((if ,q ,a ,e) `(if ,((optimize env) q)
                            ,((optimize env) a)
                            ,((optimize env) e)))
        ((begin . ,exps) (cons 'begin (map (optimize env) exps)))
        ((let ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (optimize env) e*))
                    (body ((optimize env) body)))
                (Let x* e* body)))))
        ((letrec ,bds (closures ,c* ,body))
         (: bds
            (lambda (l* e*)
              (let* ((x* (map car c*))
                     (env (append (map cons x* l*) env))
                     (e* (map (lambda (e)
                                (match e
                                  ((lambda ,x* (free ,f* ,body))
                                   `(lambda ,x* (free ,f* ,((optimize env) body)))))) e*))
                     (body ((optimize env) body)))
                (Letrec l* e* `(closures ,c* ,body))))))
        ((,rator . ,rands)
         (let ((rator (cond ((assq rator env) => cdr)
                            (else rator)))
               (rands (map (optimize env) rands)))
           (cons rator rands))))))
  ((optimize '()) x))
(define (introduce-procedure-primitives x)
  (define (lookup x cp f*)
    (let loop ((f* f*) (i 0))
      (cond ((null? f*) x)
            ((eq? (car f*) x) `(closure-ref ,cp (quote ,i)))
            (else (loop (cdr f*) (+ i 1))))))
  (define (build-set!s c cp f*)
    (let ((x (car c)) (f* (map (intro cp f*) (caddr c))))
      (let loop ((f* f*) (i 0) (result '()))
        (if (null? f*)
            (reverse result)
            (loop (cdr f*) (+ i 1)
                  (cons `(closure-set! ,x (quote ,i) ,(car f*)) result))))))
  (define (intro cp f*)
    (lambda (exp)
      (match exp
        ((quote ,d) exp)
        (,x (guard (symbol? x)) (lookup x cp f*)) ;x may be a label or prim
        ((if ,q ,a ,e) `(if ,((intro cp f*) q)
                            ,((intro cp f*) a)
                            ,((intro cp f*) e)))
        ((begin . ,exps) (cons 'begin (map (intro cp f*) exps)))
        ((let ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (intro cp f*) e*))
                    (body ((intro cp f*) body)))
                (Let x* e* body)))))
        ((letrec ,bds (closures ,c* ,body))
         (: bds
            (lambda (l* e*)
              (let ((set!s (apply append (map (lambda (c) (build-set!s c cp f*)) c*)))
                    (closure-bds (map (lambda (c)
                                        (let ((x (car c)) (l (cadr c)) (f* (caddr c)))
                                          `(,x (make-closure ,l (quote ,(length f*)))))) c*))
                    (e* (map (lambda (e)
                               (match e
                                 ((lambda ,x* (free ,f* ,body))
                                  (let ((cp (car x*)))
                                    `(lambda ,x* ,((intro cp f*) body)))))) e*))
                    (body ((intro cp f*) body)))
                (Letrec l* e* `(let ,closure-bds ,(make-begin (append set!s (list body)))))))))
        ((,rator . ,rands)
         (let ((rator (cond ((prim? rator) rator)
                            ((label? rator) rator)
                            (else `(closure-code ,(lookup rator cp f*)))))
               (rands (map (intro cp f*) rands)))
           (cons rator rands))))))
  ((intro #f '()) x))
(define test
  (compose pretty-print
           introduce-procedure-primitives
           optimize-known-call
           convert-closures
           uncover-free
           compile0))
