#lang racket
(define-syntax match
  (syntax-rules (else guard)
    ((_ v) (error 'match "~s" v))
    ((_ v (else e ...)) (begin e ...))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (begin e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (begin e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (equal? v (quote lit)) kt kf))))
(define (target-fixnum? x)
  (and (integer? x)
       (exact? x)
       (<= (- (expt 2 60)) x (- (expt 2 60) 1))))
(define (datum? x)
  (or (null? x) (boolean? x) (target-fixnum? x)
      (and (pair? x) (datum? (car x)) (datum? (cdr x)))
      (and (vector? x)
           (let ((len (vector-length x)))
             (let loop ((i 0))
               (cond ((= len i) #t)
                     ((datum? (vector-ref x i)) (loop (+ i 1)))
                     (else #f)))))))
(define counter
  (let ((n 0))
    (lambda ()
      (set! n (+ n 1))
      n)))
(define (unique-symbol x)
  (string->symbol
   (format "~a.~s" x (counter))))
(define (set? x)
  (cond ((null? x) #t)
        ((memq (car x) (cdr x)) #f)
        (else (set? (cdr x)))))
(define (set-cons x s)
  (if (memq x s)
      s
      (cons x s)))
(define (U s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (U (cdr s1) s2))
        (else (cons (car s1) (U (cdr s1) s2)))))
(define (I s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (cons (car s1) (I (cdr s1) s2)))
        (else (I (cdr s1) s2))))
(define (D s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (D (cdr s1) s2))
        (else (cons (car s1) (D (cdr s1) s2)))))
(define (: bds k)
  (k (map car bds) (map cadr bds)))
(define (Let x* e* body)
  (list 'let (map list x* e*) body))
(define (Letrec x* e* body)
  (list 'letrec (map list x* e*) body))
(define prims
  '(+ - * = < > <= >= null? fixnum? boolean? procedure? pair? vector? box? eq? not
      cons car cdr set-car! set-cdr! box unbox set-box! make-vector vector-length
      vector-ref vector-set! void))
(define (prim? x)
  (memq x prims))
(define (parse-scheme x)
  (define prim-env
    '((+ . +)
      (- . -)
      (* . *)
      (= . =)
      (< . <)
      (> . >)
      (<= . <=)
      (>= . >=)
      (null? . null?)
      (fixnum? . fixnum?)
      (boolean? . boolean?)
      (procedure? . procedure?)
      (pair? . pair?)
      (vector? . vector?)
      (box? . box?)
      (eq? . eq?)
      (not . not)
      (cons . cons)
      (car . car)
      (cdr . cdr)
      (set-car! . set-car!)
      (set-cdr! . set-cdr!)
      (box . box)
      (unbox . unbox)
      (set-box! . set-box!)
      (make-vector . make-vector)
      (vector-length . vector-length)
      (vector-ref . vector-ref)
      (vector-set! . vector-set!)
      (void . void)))
  (define (lookup var env)
    (cond ((assq var env) => cdr)
          (else (error 'parse-scheme "unbound variable ~s" var))))
  (define (make-body exps env)
    (cond ((null? exps) (error 'parse-scheme "empty begin body"))
          ((null? (cdr exps)) ((parse0 env) (car exps)))
          (else (cons 'begin (map (parse0 env) exps)))))
  (define (parse0 env)
    (lambda (exp)
      (match exp
        (,n (guard (number? n)) (if (target-fixnum? n)
                                    `(quote ,n)
                                    (error 'parse-scheme "invalid number ~s" n)))
        (,b (guard (boolean? b)) `(quote ,b))
        (,x (guard (symbol? x)) (lookup x env))
        ((,rator . ,rands) (if (symbol? rator)
                               (let ((a (assq rator env)))
                                 (if a
                                     (let ((rator (cdr a))
                                           (rands (map (parse0 env) rands)))
                                       (if (eq? rator 'not)
                                           `(if ,(car rands) '#f '#t)
                                           (cons rator rands)))
                                     ((parse1 env) exp)))
                               (map (parse0 env) exp)))
        (else (error 'parse-scheme "invalid input ~s" exp)))))
  (define (parse1 env)
    (lambda (exp)
      (match exp
        ((quote ,d) (if (datum? d)
                        exp
                        (error 'parse-scheme "invalid datum ~s" d)))
        ((if ,q ,a) `(if ,((parse0 env) q) ,((parse0 env) a) (void)))
        ((if ,q ,a ,e) `(if ,((parse0 env) q) ,((parse0 env) a) ,((parse0 env) e)))
        ((set! ,x ,e) `(set! ,(lookup x env) ,((parse0 env) e)))
        ((begin . ,exps) (make-body exps env))
        ((and . ,exps) (if (null? exps)
                           ''#t
                           (let ((exps (map (parse0 env) exps)))
                             (let loop ((exp (car exps)) (exps (cdr exps)))
                               (if (null? exps)
                                   exp
                                   `(if ,exp ,(loop (car exps) (cdr exps)) '#f))))))
        ((or . ,exps) (if (null? exps)
                          ''#f
                          (let ((exps (map (parse0 env) exps)))
                            (let loop ((exp (car exps)) (exps (cdr exps)))
                              (if (null? exps)
                                  exp
                                  (let ((t (unique-symbol 't)))
                                    `(let ((,t ,exp))
                                       (if ,t ,t ,(loop (car exps) (cdr exps))))))))))
        ((lambda ,x* . ,exps)
         (unless (set? x*)
           (error 'parse-scheme "invalid formals ~s" x*))
         (let* ((x*^ (map unique-symbol x*))
                (env (append (map cons x* x*^) env))
                (body (make-body exps env)))
           `(lambda ,x*^ ,body)))
        ((let ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid let LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse0 env) e*))
                     (body (make-body exps env^)))
                (Let x*^ e* body)))))
        ((letrec ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid letrec LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse0 env^) e*))
                     (body (make-body exps env^)))
                (Letrec x*^ e* body)))))
        (else (error 'parse-scheme "unbound variable ~s" (car exp))))))
  ((parse0 prim-env) x))
(define (convert-complex-datum x)
  (define (convert-datum x)
    (cond ((pair? x) (list 'cons (convert-datum (car x)) (convert-datum (cdr x))))
          ((vector? x)
           (let ((l (vector-length x)))
             (if (= l 0)
                 '(make-vector '0)
                 (let ((t (unique-symbol 't)))
                   `(let ((,t (make-vector (quote ,l))))
                      ,(let loop ((i l) (e* (cons t '())))
                         (if (= i 0)
                             (cons 'begin e*)
                             (let ((i (- i 1)))
                               (loop i
                                     (cons
                                      `(vector-set! ,t (quote ,i) ,(convert-datum (vector-ref x i)))
                                      e*))))))))))
          (else `(quote ,x))))
  (define bindings '())
  (define (convert exp)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (let ((t (unique-symbol 't)))
                        (set! bindings (cons (list t (convert-datum d)) bindings))
                        t)
                      exp))
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(convert q) ,(convert a) ,(convert e)))
      ((begin . ,exps) (cons 'begin (map convert exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(convert body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Letrec x* e* body)))))
      (else (map convert exp))))
  (let ((x (convert x)))
    (if (null? bindings)
        x
        `(let ,bindings ,x))))
(define (uncover-assigned x)
  (define (uncover-exps exps)
    (if (null? exps)
        (values '() '())
        (let-values (((a u*0) (uncover (car exps)))
                     ((d u*1) (uncover-exps (cdr exps))))
          (values (cons a d) (U u*0 u*1)))))
  (define (uncover exp)
    (match exp
      ((quote ,d) (values exp '()))
      (,x (guard (symbol? x)) (values x '()))
      ((if ,q ,a ,e) (let-values (((q u*0) (uncover q))
                                  ((a u*1) (uncover a))
                                  ((e u*2) (uncover e)))
                       (values `(if ,q ,a ,e) (U (U u*0 u*1) u*2))))
      ((set! ,x ,e) (let-values (((e u*) (uncover e)))
                      (values `(set! ,x ,e) (set-cons x u*))))
      ((begin . ,exps) (let-values (((exps u*) (uncover-exps exps)))
                         (values (cons 'begin exps) u*)))
      ((lambda ,x* ,body) (let-values (((body u*) (uncover body)))
                            (values `(lambda ,x*
                                       (assigned ,(I x* u*) ,body))
                                    (D u* x*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (values (Let x* e* `(assigned ,(I x* u*1) ,body))
                      (U u*0 (D u*1 x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (let ((u*2 (U u*0 u*1)))
                (values (Letrec x* e* `(assigned ,(I x* u*2) ,body))
                        (D u*2 x*)))))))
      (else (uncover-exps exp))))
  (let-values (((x u*) (uncover x)))
    (if (null? u*)
        x
        (error 'uncover-assigned "unbound assigned variables ~s" u*))))
(define (purify-letrec x)
  (define (Let x* e* a* body)
    (if (null? x*)
        body
        (list 'let (map list x* e*) `(assigned ,a* ,body))))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        (list 'letrec (map list x* e*) body)))
  (define (purify exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(purify q) ,(purify a) ,(purify e)))
      ((set! ,x ,e) `(set! ,x ,(purify e)))
      ((begin . ,exps) (cons 'begin (map purify exps)))
      ((lambda ,x* (assigned ,a* ,body))
       `(lambda ,x* (assigned ,a* ,(purify body))))
      ((let ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (Let x* e* a* body)))))
      ((letrec ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body))
                  (lambda? (lambda (x) (and (pair? x) (eq? (car x) 'lambda))))
                  (bound? (lambda (x) (memq x x*)))
                  (assigned? (lambda (x) (memq x a*))))
              (define (simple? e)
                (match e
                  ((quote ,d) #t)
                  (,x (guard (symbol? x)) (not (bound? x)))
                  ((,prim . ,rands) (guard (prim? prim)) (andmap simple? rands))
                  (else #f)))
              (let loop ((x* x*) (e* e*) (xs* '()) (es* '()) (xl* '()) (el* '()) (xc* '()) (ec* '()))
                (if (null? x*)
                    (Let xs* es* '()
                         (Let xc* (make-list (length xc*) '(void)) xc*
                              (Letrec xl* el*
                                      (let ((xt* (map (lambda (xc) (unique-symbol 't)) xc*)))
                                        (Let xt* ec* '()
                                             `(begin ,@(map (lambda (xc xt) `(set! ,xc ,xt)) xc* xt*)
                                                     ,body))))))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (assigned? x)
                          (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))
                          (if (lambda? e)
                              (loop x* e* xs* es* (cons x xl*) (cons e el*) xc* ec*)
                              (if (simple? e)
                                  (loop x* e* (cons x xs*) (cons e es*) xl* el* xc* ec*)
                                  (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))))))))))))
      (else (map purify exp))))
  (purify x))
(define (convert-assignments x)
  (define (convert env)
    (lambda (exp)
      (match exp
        ((quote ,d) exp)
        (,x (guard (symbol? x)) (if (memq x env) `(unbox ,x) x))
        ((if ,q ,a ,e) `(if ,((convert env) q) ,((convert env) a) ,((convert env) e)))
        ((set! ,x ,e) `(set-box! ,x ,((convert env) e)))
        ((begin . ,exps) (cons 'begin (map (convert env) exps)))
        ((lambda ,x* (assigned ,a* ,body))
         (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                (bds (map cons a* t*))
                (lookup (lambda (x)
                          (cond ((assq x bds) => cdr)
                                (else x))))
                (x*^ (map lookup x*))
                (e* (map (lambda (t) `(box ,t)) t*)))
           `(lambda ,x*^
              ,(Let a* e* ((convert (append a* env)) body)))))
        ((let ,bds (assigned ,a* ,body))
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert (append a* env)) body)))
                (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                       (bds (map cons a* t*))
                       (lookup (lambda (x)
                                 (cond ((assq x bds) => cdr)
                                       (else x))))
                       (x*^ (map lookup x*))
                       (e*^ (map (lambda (t) `(box ,t)) t*)))
                  (Let x*^ e* (Let a* e*^ body)))))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert env) body)))
                (Letrec x* e* body)))))
        (else (map (convert env) exp)))))
  ((convert '()) x))
(define (optimize-direct-call x)
  (define (optimize exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(optimize q) ,(optimize a) ,(optimize e)))
      ((begin . ,exps) (cons 'begin (map optimize exps)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map optimize e*))
                  (body (optimize body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map optimize e*))
                  (body (optimize body)))
              (Letrec x* e* body)))))
      (((lambda ,x* ,body) . ,e*)
       (let ((e* (map optimize e*))
             (body (optimize body)))
         (Let x* e* body)))
      (else (map optimize exp))))
  (optimize x))
(define (remove-anonymous-lambda x)
  (define (remove exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(remove q) ,(remove a) ,(remove e)))
      ((begin . ,exps) (cons 'begin (map remove exps)))
      ((lambda ,x* ,body) (let ((t (unique-symbol 't)))
                            `(letrec ((,t (lambda ,x* ,(remove body)))) ,t)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body)))
                               (else (remove e)))) e*))
                  (body (remove body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body))))) e*))
                  (body (remove body)))
              (Letrec x* e* body)))))
      (else (map remove exp))))
  (remove x))
(define (sanitize-binding-forms x)
  (define (Let x* e* body)
    (if (null? x*)
        body
        (list 'let (map list x* e*) body)))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        (list 'letrec (map list x* e*) body)))
  (define (sanitize exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(sanitize q) ,(sanitize a) ,(sanitize e)))
      ((begin . ,exps) (make-begin (map sanitize exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(sanitize body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (let loop ((x* x*) (e* e*) (xo* '()) (eo* '()) (xl* '()) (el* '()))
                (if (null? x*)
                    (Letrec xl* el* (Let xo* eo* body))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (and (pair? e) (eq? (car e) 'lambda))
                          (loop x* e* xo* eo* (cons x xl*) (cons e el*))
                          (loop x* e* (cons x xo*) (cons e eo*) xl* el*)))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (Letrec x* e* body)))))
      (else (map sanitize exp))))
  (sanitize x))
