#lang racket
(define-syntax match
  (syntax-rules (else guard)
    ((_ v) (error 'match "~s" v))
    ((_ v (else e ...)) (begin e ...))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (begin e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (begin e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (eq? v (quote lit)) kt kf))))
(define counter
  (let ((n 0))
    (lambda ()
      (set! n (+ n 1))
      n)))
(define (unique-symbol x)
  (string->symbol
   (format "~a.~s" x (counter))))
(define (target-fixnum? x)
  (and (integer? x)
       (exact? x)
       (<= (- (expt 2 60)) x (- (expt 2 60) 1))))
(define (datum? x)
  (or (null? x) (boolean? x) (target-fixnum? x)
      (and (pair? x) (datum? (car x)) (datum? (cdr x)))
      (and (vector? x)
           (let ((len (vector-length x)))
             (let loop ((i 0))
               (cond ((= len i) #t)
                     ((datum? (vector-ref x i)) (loop (+ i 1)))
                     (else #f)))))))
(define (compose2 f g)
  (lambda (x)
    (f (g x))))
(define-syntax compose
  (syntax-rules ()
    ((_ f) f)
    ((_ f g ...) (compose2 f (compose g ...)))))
(define (make-begin exps)
  (define (flatten exp)
    (match exp
      ((begin . ,exps) (apply append (map flatten exps)))
      (else (list exp))))
  (let ((exps (apply append (map flatten exps))))
    (if (null? (cdr exps))
        (car exps)
        (cons 'begin exps))))
(define (set? x)
  (cond ((null? x) #t)
        ((memq (car x) (cdr x)) #f)
        (else (set? (cdr x)))))
(define (set-cons x s)
  (if (memq x s)
      s
      (cons x s)))
(define (U s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (U (cdr s1) s2))
        (else (cons (car s1) (U (cdr s1) s2)))))
(define (I s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (cons (car s1) (I (cdr s1) s2)))
        (else (I (cdr s1) s2))))
(define (D s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (D (cdr s1) s2))
        (else (cons (car s1) (D (cdr s1) s2)))))
(define (: bds k)
  (k (map car bds) (map cadr bds)))
(define (Let x* e* body)
  (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) body))
(define (Letrec x* e* body)
  (list 'letrec (map (lambda (x e) (cons x (cons e '()))) x* e*) body))
;<exp> ::= <fixnum>
;       |  <boolean>
;       |  (quote <datum>)
;       |  <var>
;       |  (if <exp> <exp>)
;       |  (if <exp> <exp> <exp>)
;       |  (set! <var> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<var>*) <exp>+)
;       |  (let ((<var> <exp>)*) <exp>+)
;       |  (letrec ((<var> <exp>)*) <exp>+)
;       |  (and <exp>*)
;       |  (or <exp>*)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
;<datum> ::= ()
;         |  <boolean>
;         |  <fixnum>
;         |  (<datum> . <datum>)
;         |  #(<datum>*)
;<boolean> ::= #t
;           |  #f
(define (parse-scheme exp)
  (define prim-env
    '((+ . 2)
      (- . 2)
      (* . 2)
      (= . 2)
      (< . 2)
      (> . 2)
      (<= . 2)
      (>= . 2)
      (null? . 1)
      (boolean? . 1)
      (fixnum? . 1)
      (pair? . 1)
      (vector? . 1)
      (box? . 1)
      (procedure? . 1)
      (eq? . 2)
      (not . 1)
      (cons . 2)
      (car . 1)
      (cdr . 1)
      (set-car! . 2)
      (set-cdr! . 2)
      (make-vector . 1)
      (vector-length . 1)
      (vector-ref . 2)
      (vector-set! . 3)
      (box . 1)
      (unbox . 1)
      (set-box! . 2)
      (void . 0)))
  (define (make-body exps env)
    (cond ((null? exps) (error 'parse-scheme "empty begin body"))
          ((null? (cdr exps)) ((parse env) (car exps)))
          (else (cons 'begin (map (parse env) exps)))))
  (define (parse env)
    (lambda (exp)
      (match exp
        (,n (guard (number? n)) (if (target-fixnum? n)
                                    `(quote ,n)
                                    (error 'parse-scheme "invalid number ~s" n)))
        (,b (guard (boolean? b)) `(quote ,b))
        (,x (guard (symbol? x)) (cond ((assq x env) => cdr)
                                      (else (error 'parse-scheme "unbound variable ~s" x))))
        ((,rator . ,rands) (if (symbol? rator)
                               (let ((a (assq rator env)))
                                 (if a
                                     (let ((rator (cdr a))
                                           (rands (map (parse env) rands)))
                                       (cons rator rands))
                                     (let ((a (assq rator prim-env)))
                                       (if a
                                           (let ((arity (cdr a)))
                                             (unless (= (length rands) arity)
                                               (error 'parse-scheme
                                                      "arity mismatch expected ~s given ~s"
                                                      arity (length rands)))
                                             (let ((rands (map (parse env) rands)))
                                               (if (eq? rator 'not)
                                                   `(if ,(car rands) '#f '#t)
                                                   (cons rator rands))))
                                           ((parse-form env) exp)))))
                               (map (parse env) exp))))))
  (define (parse-form env)
    (lambda (exp)
      (match exp
        ((quote ,d) (if (datum? d)
                        exp
                        (error 'parse-scheme "invalid datum ~s" d)))
        ((if ,q ,a) `(if ,((parse env) q) ,((parse env) a) (void)))
        ((if ,q ,a ,e) `(if ,((parse env) q) ,((parse env) a) ,((parse env) e)))
        ((set! ,x ,e) (let ((x (cond ((assq x env) => cdr)
                                     ((assq x prim-env)
                                      (error 'parse-scheme "can't assign to prim ~s" x))
                                     (else (error 'parse-scheme "unbound variable ~s" x))))
                            (e ((parse env) e)))
                        `(set! ,x ,e)))
        ((begin . ,exps) (make-body exps env))
        ((and . ,exps) (if (null? exps)
                           ''#t
                           (let ((exps (map (parse env) exps)))
                             (let loop ((exp (car exps)) (exps (cdr exps)))
                               (if (null? exps)
                                   exp
                                   `(if ,exp ,(loop (car exps) (cdr exps)) '#f))))))
        ((or . ,exps) (if (null? exps)
                          ''#f
                          (let ((exps (map (parse env) exps)))
                            (let loop ((exp (car exps)) (exps (cdr exps)))
                              (if (null? exps)
                                  exp
                                  (let ((t (unique-symbol 't)))
                                    `(let ((,t ,exp))
                                       (if ,t ,t ,(loop (car exps) (cdr exps))))))))))
        ((lambda ,x* . ,exps)
         (unless (set? x*)
           (error 'parse-scheme "invalid formals ~s" x*))
         (let* ((x*^ (map unique-symbol x*))
                (env (append (map cons x* x*^) env))
                (body (make-body exps env)))
           `(lambda ,x*^ ,body)))
        ((let ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid let LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env) e*))
                     (body (make-body exps env^)))
                (Let x*^ e* body)))))
        ((letrec ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid letrec LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env^) e*))
                     (body (make-body exps env^)))
                (Letrec x*^ e* body)))))
        (else (error 'parse-scheme "unbound variable ~s" (car exp))))))
  ((parse '()) exp))
;<exp> ::= (quote <datum>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (set! <uvar> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) <exp>)
;       |  (let ((<uvar> <exp>)*) <exp>)
;       |  (letrec ((<uvar> <exp>)*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define (convert-complex-datum exp)
  (define (convert-datum x)
    (cond ((pair? x) (list 'cons (convert-datum (car x)) (convert-datum (cdr x))))
          ((vector? x)
           (let ((l (vector-length x)))
             (if (= l 0)
                 '(make-vector '0)
                 (let ((t (unique-symbol 't)))
                   `(let ((,t (make-vector (quote ,l))))
                      ,(let loop ((i l) (e* (cons t '())))
                         (if (= i 0)
                             (cons 'begin e*)
                             (let ((i (- i 1)))
                               (loop i
                                     (cons
                                      `(vector-set! ,t (quote ,i) ,(convert-datum (vector-ref x i)))
                                      e*))))))))))
          (else `(quote ,x))))
  (define bindings '())
  (define (convert exp)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (let ((t (unique-symbol 't)))
                        (set! bindings (cons (list t (convert-datum d)) bindings))
                        t)
                      exp))
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(convert q) ,(convert a) ,(convert e)))
      ((begin . ,exps) (cons 'begin (map convert exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(convert body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Letrec x* e* body)))))
      (else (map convert exp))))
  (let ((exp (convert exp)))
    (if (null? bindings)
        exp
        `(let ,bindings ,exp))))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (set! <uvar> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) <exp>)
;       |  (let ((<uvar> <exp>)*) <exp>)
;       |  (letrec ((<uvar> <exp>)*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
;<immediate> ::= ()
;             |  <boolean>
;             |  <fixnum>
(define (uncover-assigned exp)
  (define (uncover-exps exps)
    (if (null? exps)
        (values '() '())
        (let-values (((a u*0) (uncover (car exps)))
                     ((d u*1) (uncover-exps (cdr exps))))
          (values (cons a d) (U u*0 u*1)))))
  (define (uncover exp)
    (match exp
      ((quote ,i) (values exp '()))
      (,x (guard (symbol? x)) (values x '()))
      ((if ,q ,a ,e) (let-values (((q u*0) (uncover q))
                                  ((a u*1) (uncover a))
                                  ((e u*2) (uncover e)))
                       (values `(if ,q ,a ,e) (U (U u*0 u*1) u*2))))
      ((set! ,x ,e) (let-values (((e u*) (uncover e)))
                      (values `(set! ,x ,e) (set-cons x u*))))
      ((begin . ,exps) (let-values (((exps u*) (uncover-exps exps)))
                         (values (cons 'begin exps) u*)))
      ((lambda ,x* ,body) (let-values (((body u*) (uncover body)))
                            (values `(lambda ,x*
                                       (assigned ,(I x* u*) ,body))
                                    (D u* x*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (values (Let x* e* `(assigned ,(I x* u*1) ,body))
                      (U u*0 (D u*1 x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (let ((u*2 (U u*0 u*1)))
                (values (Letrec x* e* `(assigned ,(I x* u*2) ,body))
                        (D u*2 x*)))))))
      (else (uncover-exps exp))))
  (let-values (((exp u*) (uncover exp)))
    (if (null? u*)
        exp
        (error 'uncover-assigned "unbound assigned variables ~s" u*))))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (set! <uvar> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) (assigned (<uvar>*) <exp>))
;       |  (let ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;       |  (letrec ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define (purify-letrec exp)
  (define effect-free-prims
    '(+ - * = < > <= >= null? fixnum? boolean? procedure? pair? vector? box? eq?
        cons car cdr box unbox make-vector vector-length vector-ref void))
  (define (effect-free-prim? x)
    (memq x effect-free-prims))
  (define (Let x* e* a* body)
    (if (null? x*)
        body
        (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) `(assigned ,a* ,body))))
  (define (purify exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(purify q) ,(purify a) ,(purify e)))
      ((set! ,x ,e) `(set! ,x ,(purify e)))
      ((begin . ,exps) (cons 'begin (map purify exps)))
      ((lambda ,x* (assigned ,a* ,body))
       `(lambda ,x* (assigned ,a* ,(purify body))))
      ((let ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (Let x* e* a* body)))))
      ((letrec ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body))
                  (lambda? (lambda (x) (and (pair? x) (eq? (car x) 'lambda))))
                  (bound? (lambda (x) (memq x x*)))
                  (assigned? (lambda (x) (memq x a*))))
              (define (simple? e)
                (match e
                  ((quote ,d) #t)
                  (,x (guard (symbol? x)) (not (bound? x)))
                  ((if ,q ,a ,e) (and (simple? q) (simple? a) (simple? e)))
                  ((begin . ,e*) (andmap simple? e*))
                  ((,prim . ,rands) (guard (effect-free-prim? prim)) (andmap simple? rands))
                  (else #f)))
              (let loop ((x* x*) (e* e*) (xs* '()) (es* '()) (xl* '()) (el* '()) (xc* '()) (ec* '()))
                (if (null? x*)
                    (Let xs* es* '()
                         (Let xc* (make-list (length xc*) '(void)) xc*
                              (Letrec xl* el*
                                      (let ((xt* (map (lambda (xc) (unique-symbol 't)) xc*)))
                                        (Let xt* ec* '()
                                             `(begin ,@(map (lambda (xc xt) `(set! ,xc ,xt)) xc* xt*)
                                                     ,body))))))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (assigned? x)
                          (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))
                          (if (lambda? e)
                              (loop x* e* xs* es* (cons x xl*) (cons e el*) xc* ec*)
                              (if (simple? e)
                                  (loop x* e* (cons x xs*) (cons e es*) xl* el* xc* ec*)
                                  (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))))))))))))
      (else (map purify exp))))
  (purify exp))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (set! <uvar> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) (assigned (<uvar>*) <exp>))
;       |  (let ((<uvar> <exp>)*) (assigned (<uvar>*) <exp>))
;       |  (letrec ((<uvar> (lambda (<uvar>*) <exp>))*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define (convert-assignments exp)
  (define (convert env)
    (lambda (exp)
      (match exp
        ((quote ,i) exp)
        (,x (guard (symbol? x)) (if (memq x env) `(unbox ,x) x))
        ((if ,q ,a ,e) `(if ,((convert env) q) ,((convert env) a) ,((convert env) e)))
        ((set! ,x ,e) `(set-box! ,x ,((convert env) e)))
        ((begin . ,exps) (cons 'begin (map (convert env) exps)))
        ((lambda ,x* (assigned ,a* ,body))
         (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                (bds (map cons a* t*))
                (lookup (lambda (x)
                          (cond ((assq x bds) => cdr)
                                (else x))))
                (x*^ (map lookup x*))
                (e* (map (lambda (t) `(box ,t)) t*)))
           `(lambda ,x*^
              ,(Let a* e* ((convert (append a* env)) body)))))
        ((let ,bds (assigned ,a* ,body))
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert (append a* env)) body)))
                (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                       (bds (map cons a* t*))
                       (lookup (lambda (x)
                                 (cond ((assq x bds) => cdr)
                                       (else x))))
                       (x*^ (map lookup x*))
                       (e*^ (map (lambda (t) `(box ,t)) t*)))
                  (Let x*^ e* (Let a* e*^ body)))))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert env) body)))
                (Letrec x* e* body)))))
        (else (map (convert env) exp)))))
  ((convert '()) exp))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) <exp>)
;       |  (let ((<uvar> <exp>)*) <exp>)
;       |  (letrec ((<uvar> (lambda (<uvar>*) <exp>))*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define (propagate-constant exp)
  (define (quote? x)
    (and (pair? x) (eq? (car x) 'quote)))
  (define (pro env)
    (lambda (exp)
      (match exp
        ((quote ,i) exp)
        (,x (guard (symbol? x)) (cond ((assq x env) => cdr)
                                      (else x)))
        ((if ,q ,a ,e) (let ((q ((pro env) q))
                             (a ((pro env) a))
                             (e ((pro env) e)))
                         (if (quote? q)
                             (if (eq? (cadr q) #f) e a)
                             `(if ,q ,a ,e))))
        ((begin . ,exps) (cons 'begin (map (pro env) exps)))
        ((lambda ,x* ,body) `(lambda ,x* ,((pro env) body)))
        ((let ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (pro env) e*)))
                (let loop ((x* x*) (e* e*) (xs* '()) (es* '()) (xc* '()) (ec* '()))
                  (if (null? x*)
                      (Let xc* ec* ((pro (append (map cons xs* es*) env)) body))
                      (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                        (if (or (quote? e) (symbol? e))
                            (loop x* e* (cons x xs*) (cons e es*) xc* ec*)
                            (loop x* e* xs* es* (cons x xc*) (cons e ec*))))))))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (pro env) e*))
                    (body ((pro env) body)))
                (Letrec x* e* body)))))
        ((,prim ,a) (guard (memq prim '(null? boolean? fixnum?)))
                    (let ((a ((pro env) a)))
                      (if (quote? a)
                          `(quote ,((eval prim) (cadr a)))
                          `(,prim ,a))))
        ((,prim ,a ,b) (guard (memq prim '(+ - * = < > <= >= eq?)))
                       (let ((a ((pro env) a)) (b ((pro env) b)))
                         (if (and (quote? a) (quote? b))
                             `(quote ,((eval prim) (cadr a) (cadr b)))
                             `(,prim ,a ,b))))
        (((lambda ,x* ,body) . ,e*)
         ((pro env) (Let x* e* body)))
        (else (map (pro env) exp)))))
  ((pro '()) exp))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) <exp>)
;       |  (let ((<uvar> <exp>)*) <exp>)
;       |  (letrec ((<uvar> (lambda (<uvar>*) <exp>))*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define (remove-anonymous-lambda exp)
  (define (remove exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(remove q) ,(remove a) ,(remove e)))
      ((begin . ,exps) (cons 'begin (map remove exps)))
      ((lambda ,x* ,body) (let ((t (unique-symbol 't)))
                            `(letrec ((,t (lambda ,x* ,(remove body)))) ,t)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body)))
                               (else (remove e)))) e*))
                  (body (remove body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body))))) e*))
                  (body (remove body)))
              (Letrec x* e* body)))))
      (else (map remove exp))))
  (remove exp))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (begin <exp>+)
;       |  (lambda (<uvar>*) <exp>)
;       |  (let ((<uvar> <exp>)*) <exp>)
;       |  (letrec ((<uvar> (lambda (<uvar>*) <exp>))*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define (sanitize-binding-forms exp)
  (define (Let x* e* body)
    (if (null? x*)
        body
        (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) body)))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        (list 'letrec (map (lambda (x e) (cons x (cons e '()))) x* e*) body)))
  (define (sanitize exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(sanitize q) ,(sanitize a) ,(sanitize e)))
      ((begin . ,exps) (make-begin (map sanitize exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(sanitize body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (let loop ((x* x*) (e* e*) (xo* '()) (eo* '()) (xl* '()) (el* '()))
                (if (null? x*)
                    (Letrec xl* el* (Let xo* eo* body))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (and (pair? e) (eq? (car e) 'lambda))
                          (loop x* e* xo* eo* (cons x xl*) (cons e el*))
                          (loop x* e* (cons x xo*) (cons e eo*) xl* el*)))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (Letrec x* e* body)))))
      (else (map sanitize exp))))
  (sanitize exp))
;<exp> ::= (quote <immediate>)
;       |  <uvar>
;       |  (if <exp> <exp> <exp>)
;       |  (begin <exp>+)
;       |  (let ((<uvar> <exp>)*) <exp>)
;       |  (letrec ((<uvar> (lambda (<uvar>*) <exp>))*) <exp>)
;       |  (<prim> <exp>*)
;       |  (<exp> <exp>*)
(define compile0
  (compose sanitize-binding-forms
           remove-anonymous-lambda
           propagate-constant
           convert-assignments
           purify-letrec
           uncover-assigned
           convert-complex-datum
           parse-scheme))
