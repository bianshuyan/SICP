#lang racket
(define-syntax match
  (syntax-rules (else guard)
    ((_ v) (error 'match "~s" v))
    ((_ v (else e ...)) (begin e ...))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (begin e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (begin e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (eq? v (quote lit)) kt kf))))
(define (target-fixnum? x)
  (and (integer? x)
       (exact? x)
       (<= (- (expt 2 60)) x (- (expt 2 60) 1))))
(define (datum? x)
  (or (null? x) (boolean? x) (target-fixnum? x)
      (and (pair? x) (datum? (car x)) (datum? (cdr x)))
      (and (vector? x)
           (let ((len (vector-length x)))
             (let loop ((i 0))
               (cond ((= len i) #t)
                     ((datum? (vector-ref x i)) (loop (+ i 1)))
                     (else #f)))))))
(define (compose2 f g)
  (lambda (x)
    (f (g x))))
(define-syntax compose
  (syntax-rules ()
    ((_ f) f)
    ((_ f g ...) (compose2 f (compose g ...)))))
(define counter
  (let ((n 0))
    (lambda ()
      (set! n (+ n 1))
      n)))
(define (unique-symbol x)
  (string->symbol
   (format "~a.~s" x (counter))))
(define (unique-label x)
  (string->symbol
   (format "~a$~s" x (counter))))
(define (unique-symbols n)
  (let loop ((n n) (result '()))
    (if (= n 0)
        result
        (loop (- n 1) (cons (unique-symbol 't) result)))))
(define extract-root
  (lambda (sym)
    (list->string
     (let ([chars (string->list (symbol->string sym))])
       (define (s0 ls)
         (cond
           [(null? ls) chars]
           [(char-numeric? (car ls)) (s1 (cdr ls))]
           [else chars]))
       (define (s1 ls)
         (cond
           [(null? ls) chars]
           [(char-numeric? (car ls)) (s1 (cdr ls))]
           [(memv (car ls) '(#\. #\$)) (reverse (cdr ls))]
           [else chars]))
       (s0 (reverse chars))))))
(define (ash m n) (arithmetic-shift m n))
(define (sra m n) (ash m (- n)))
(define (set? x)
  (cond ((null? x) #t)
        ((memq (car x) (cdr x)) #f)
        (else (set? (cdr x)))))
(define (set-cons x s)
  (if (memq x s)
      s
      (cons x s)))
(define (U s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (U (cdr s1) s2))
        (else (cons (car s1) (U (cdr s1) s2)))))
(define (I s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (cons (car s1) (I (cdr s1) s2)))
        (else (I (cdr s1) s2))))
(define (D s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (D (cdr s1) s2))
        (else (cons (car s1) (D (cdr s1) s2)))))
(define (make-begin exps)
  (define (flatten exp)
    (match exp
      ((begin . ,exps) (apply append (map flatten exps)))
      (else (list exp))))
  (let ((exps (apply append (map flatten exps))))
    (if (null? (cdr exps))
        (car exps)
        (cons 'begin exps))))
(define (make-nopless-begin exps)
  (let ((exps (remove '(nop) exps)))
    (if (null? exps)
        '(nop)
        (make-begin exps))))
(define (but-last exps)
  (if (null? (cdr exps))
      '()
      (cons (car exps) (but-last (cdr exps)))))
(define (last exps)
  (if (null? (cdr exps))
      (car exps)
      (last (cdr exps))))
(define (: bds k)
  (k (map car bds) (map cadr bds)))
(define (Let x* e* body)
  (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) body))
(define (Letrec x* e* body)
  (list 'letrec (map (lambda (x e) (cons x (cons e '()))) x* e*) body))
(define prims
  '(+ - * = < > <= >= null? fixnum? boolean? procedure? pair? vector? box? eq?
      cons car cdr set-car! set-cdr! box unbox set-box! make-vector vector-length
      vector-ref vector-set! void))
(define (prim? x)
  (memq x prims))
(define (parse-scheme x)
  (define prim-env
    '((+ . 2)
      (- . 2)
      (* . 2)
      (= . 2)
      (< . 2)
      (> . 2)
      (<= . 2)
      (>= . 2)
      (null? . 1)
      (boolean? . 1)
      (fixnum? . 1)
      (pair? . 1)
      (vector? . 1)
      (box? . 1)
      (procedure? . 1)
      (eq? . 2)
      (not . 1)
      (cons . 2)
      (car . 1)
      (cdr . 1)
      (set-car! . 2)
      (set-cdr! . 2)
      (make-vector . 1)
      (vector-length . 1)
      (vector-ref . 2)
      (vector-set! . 3)
      (box . 1)
      (unbox . 1)
      (set-box! . 2)
      (void . 0)))
  (define (make-body exps env)
    (cond ((null? exps) (error 'parse-scheme "empty begin body"))
          ((null? (cdr exps)) ((parse env) (car exps)))
          (else (cons 'begin (map (parse env) exps)))))
  (define (parse env)
    (lambda (exp)
      (match exp
        (,n (guard (number? n)) (if (target-fixnum? n)
                                    `(quote ,n)
                                    (error 'parse-scheme "invalid number ~s" n)))
        (,b (guard (boolean? b)) `(quote ,b))
        (,x (guard (symbol? x)) (cond ((assq x env) => cdr)
                                      ((assq x prim-env)
                                       => (lambda (p)
                                            (if (eq? x 'not)
                                                (let ((u (unique-symbol 't)))
                                                  `(lambda (,u) (if ,u '#f '#t)))
                                                (let ((arity (cdr p)))
                                                  (let ((u* (unique-symbols arity)))
                                                    `(lambda ,u* ,(cons x u*)))))))
                                      (else (error 'parse-scheme "unbound variable ~s" x))))
        ((,rator . ,rands) (if (symbol? rator)
                               (let ((a (assq rator env)))
                                 (if a
                                     (let ((rator (cdr a))
                                           (rands (map (parse env) rands)))
                                       (cons rator rands))
                                     (let ((a (assq rator prim-env)))
                                       (if a
                                           (let ((arity (cdr a)))
                                             (unless (= (length rands) arity)
                                               (error 'parse-scheme
                                                      "arity mismatch expected ~s given ~s"
                                                      arity (length rands)))
                                             (let ((rands (map (parse env) rands)))
                                               (if (eq? rator 'not)
                                                   `(if ,(car rands) '#f '#t)
                                                   (cons rator rands))))
                                           ((parse-form env) exp)))))
                               (map (parse env) exp))))))
  (define (parse-form env)
    (lambda (exp)
      (match exp
        ((quote ,d) (if (datum? d)
                        exp
                        (error 'parse-scheme "invalid datum ~s" d)))
        ((if ,q ,a) `(if ,((parse env) q) ,((parse env) a) (void)))
        ((if ,q ,a ,e) `(if ,((parse env) q) ,((parse env) a) ,((parse env) e)))
        ((set! ,x ,e) (let ((x (cond ((assq x env) => cdr)
                                     ((assq x prim-env)
                                      (error 'parse-scheme "can't assign to prim ~s" x))
                                     (else (error 'parse-scheme "unbound variable ~s" x))))
                            (e ((parse env) e)))
                        `(set! ,x ,e)))
        ((begin . ,exps) (make-body exps env))
        ((and . ,exps) (if (null? exps)
                           ''#t
                           (let ((exps (map (parse env) exps)))
                             (let loop ((exp (car exps)) (exps (cdr exps)))
                               (if (null? exps)
                                   exp
                                   `(if ,exp ,(loop (car exps) (cdr exps)) '#f))))))
        ((or . ,exps) (if (null? exps)
                          ''#f
                          (let ((exps (map (parse env) exps)))
                            (let loop ((exp (car exps)) (exps (cdr exps)))
                              (if (null? exps)
                                  exp
                                  (let ((t (unique-symbol 't)))
                                    `(let ((,t ,exp))
                                       (if ,t ,t ,(loop (car exps) (cdr exps))))))))))
        ((lambda ,x* . ,exps)
         (unless (set? x*)
           (error 'parse-scheme "invalid formals ~s" x*))
         (let* ((x*^ (map unique-symbol x*))
                (env (append (map cons x* x*^) env))
                (body (make-body exps env)))
           `(lambda ,x*^ ,body)))
        ((let ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid let LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env) e*))
                     (body (make-body exps env^)))
                (Let x*^ e* body)))))
        ((letrec ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme "invalid letrec LHS vars ~s" x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env^) e*))
                     (body (make-body exps env^)))
                (Letrec x*^ e* body)))))
        (else (error 'parse-scheme "unbound variable ~s" (car exp))))))
  ((parse '()) x))
(define (convert-complex-datum x)
  (define (convert-datum x)
    (cond ((pair? x) (list 'cons (convert-datum (car x)) (convert-datum (cdr x))))
          ((vector? x)
           (let ((l (vector-length x)))
             (if (= l 0)
                 '(make-vector '0)
                 (let ((t (unique-symbol 't)))
                   `(let ((,t (make-vector (quote ,l))))
                      ,(let loop ((i l) (e* (cons t '())))
                         (if (= i 0)
                             (cons 'begin e*)
                             (let ((i (- i 1)))
                               (loop i
                                     (cons
                                      `(vector-set! ,t (quote ,i) ,(convert-datum (vector-ref x i)))
                                      e*))))))))))
          (else `(quote ,x))))
  (define bindings '())
  (define (convert exp)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (let ((t (unique-symbol 't)))
                        (set! bindings (cons (list t (convert-datum d)) bindings))
                        t)
                      exp))
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(convert q) ,(convert a) ,(convert e)))
      ((begin . ,exps) (cons 'begin (map convert exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(convert body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Letrec x* e* body)))))
      (else (map convert exp))))
  (let ((x (convert x)))
    (if (null? bindings)
        x
        `(let ,bindings ,x))))
(define (uncover-assigned x)
  (define (uncover-exps exps)
    (if (null? exps)
        (values '() '())
        (let-values (((a u*0) (uncover (car exps)))
                     ((d u*1) (uncover-exps (cdr exps))))
          (values (cons a d) (U u*0 u*1)))))
  (define (uncover exp)
    (match exp
      ((quote ,i) (values exp '()))
      (,x (guard (symbol? x)) (values x '()))
      ((if ,q ,a ,e) (let-values (((q u*0) (uncover q))
                                  ((a u*1) (uncover a))
                                  ((e u*2) (uncover e)))
                       (values `(if ,q ,a ,e) (U (U u*0 u*1) u*2))))
      ((set! ,x ,e) (let-values (((e u*) (uncover e)))
                      (values `(set! ,x ,e) (set-cons x u*))))
      ((begin . ,exps) (let-values (((exps u*) (uncover-exps exps)))
                         (values (cons 'begin exps) u*)))
      ((lambda ,x* ,body) (let-values (((body u*) (uncover body)))
                            (values `(lambda ,x*
                                       (assigned ,(I x* u*) ,body))
                                    (D u* x*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (values (Let x* e* `(assigned ,(I x* u*1) ,body))
                      (U u*0 (D u*1 x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*0) (uncover-exps e*))
                         ((body u*1) (uncover body)))
              (let ((u*2 (U u*0 u*1)))
                (values (Letrec x* e* `(assigned ,(I x* u*2) ,body))
                        (D u*2 x*)))))))
      (else (uncover-exps exp))))
  (let-values (((x u*) (uncover x)))
    (if (null? u*)
        x
        (error 'uncover-assigned "unbound assigned variables ~s" u*))))
(define (purify-letrec x)
  (define effect-free-prims
    '(+ - * = < > <= >= null? fixnum? boolean? procedure? pair? vector? box? eq?
        cons car cdr box unbox make-vector vector-length vector-ref void))
  (define (effect-free-prim? x)
    (memq x effect-free-prims))
  (define (Let x* e* a* body)
    (if (null? x*)
        body
        (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) `(assigned ,a* ,body))))
  (define (purify exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(purify q) ,(purify a) ,(purify e)))
      ((set! ,x ,e) `(set! ,x ,(purify e)))
      ((begin . ,exps) (cons 'begin (map purify exps)))
      ((lambda ,x* (assigned ,a* ,body))
       `(lambda ,x* (assigned ,a* ,(purify body))))
      ((let ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (Let x* e* a* body)))))
      ((letrec ,bds (assigned ,a* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body))
                  (lambda? (lambda (x) (and (pair? x) (eq? (car x) 'lambda))))
                  (bound? (lambda (x) (memq x x*)))
                  (assigned? (lambda (x) (memq x a*))))
              (define (simple? e)
                (match e
                  ((quote ,d) #t)
                  (,x (guard (symbol? x)) (not (bound? x)))
                  ((if ,q ,a ,e) (and (simple? q) (simple? a) (simple? e)))
                  ((begin . ,e*) (andmap simple? e*))
                  ((,prim . ,rands) (guard (effect-free-prim? prim)) (andmap simple? rands))
                  (else #f)))
              (let loop ((x* x*) (e* e*) (xs* '()) (es* '()) (xl* '()) (el* '()) (xc* '()) (ec* '()))
                (if (null? x*)
                    (Let xs* es* '()
                         (Let xc* (make-list (length xc*) '(void)) xc*
                              (Letrec xl* el*
                                      (let ((xt* (map (lambda (xc) (unique-symbol 't)) xc*)))
                                        (Let xt* ec* '()
                                             `(begin ,@(map (lambda (xc xt) `(set! ,xc ,xt)) xc* xt*)
                                                     ,body))))))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (assigned? x)
                          (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))
                          (if (lambda? e)
                              (loop x* e* xs* es* (cons x xl*) (cons e el*) xc* ec*)
                              (if (simple? e)
                                  (loop x* e* (cons x xs*) (cons e es*) xl* el* xc* ec*)
                                  (loop x* e* xs* es* xl* el* (cons x xc*) (cons e ec*))))))))))))
      (else (map purify exp))))
  (purify x))
(define (convert-assignments x)
  (define (Let x* e* body)
    (if (null? x*)
        body
        (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) body)))
  (define (convert env)
    (lambda (exp)
      (match exp
        ((quote ,i) exp)
        (,x (guard (symbol? x)) (if (memq x env) `(unbox ,x) x))
        ((if ,q ,a ,e) `(if ,((convert env) q) ,((convert env) a) ,((convert env) e)))
        ((set! ,x ,e) `(set-box! ,x ,((convert env) e)))
        ((begin . ,exps) (cons 'begin (map (convert env) exps)))
        ((lambda ,x* (assigned ,a* ,body))
         (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                (bds (map cons a* t*))
                (lookup (lambda (x)
                          (cond ((assq x bds) => cdr)
                                (else x))))
                (x*^ (map lookup x*))
                (e* (map (lambda (t) `(box ,t)) t*)))
           `(lambda ,x*^
              ,(Let a* e* ((convert (append a* env)) body)))))
        ((let ,bds (assigned ,a* ,body))
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert (append a* env)) body)))
                (let* ((t* (map (lambda (x) (unique-symbol 't)) a*))
                       (bds (map cons a* t*))
                       (lookup (lambda (x)
                                 (cond ((assq x bds) => cdr)
                                       (else x))))
                       (x*^ (map lookup x*))
                       (e*^ (map (lambda (t) `(box ,t)) t*)))
                  (Let x*^ e* (Let a* e*^ body)))))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert env) body)))
                (Letrec x* e* body)))))
        (else (map (convert env) exp)))))
  ((convert '()) x))
(define (propagate-constant x)
  (define (quote? x)
    (and (pair? x) (eq? (car x) 'quote)))
  (define (pro env)
    (lambda (exp)
      (match exp
        ((quote ,i) exp)
        (,x (guard (symbol? x)) (cond ((assq x env) => cdr)
                                      (else x)))
        ((if ,q ,a ,e) (let ((q ((pro env) q))
                             (a ((pro env) a))
                             (e ((pro env) e)))
                         (if (quote? q)
                             (if (eq? (cadr q) #f) e a)
                             `(if ,q ,a ,e))))
        ((begin . ,exps) (cons 'begin (map (pro env) exps)))
        ((lambda ,x* ,body) `(lambda ,x* ,((pro env) body)))
        ((let ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (pro env) e*)))
                (let loop ((x* x*) (e* e*) (xs* '()) (es* '()) (xc* '()) (ec* '()))
                  (if (null? x*)
                      (Let xc* ec* ((pro (append (map cons xs* es*) env)) body))
                      (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                        (if (or (quote? e) (symbol? e))
                            (loop x* e* (cons x xs*) (cons e es*) xc* ec*)
                            (loop x* e* xs* es* (cons x xc*) (cons e ec*))))))))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (pro env) e*))
                    (body ((pro env) body)))
                (Letrec x* e* body)))))
        ((,prim ,a) (guard (memq prim '(null? boolean? fixnum?)))
                    (let ((a ((pro env) a)))
                      (if (quote? a)
                          `(quote ,((eval prim) (cadr a)))
                          `(,prim ,a))))
        ((,prim ,a ,b) (guard (memq prim '(+ - * = < > <= >= eq?)))
                       (let ((a ((pro env) a)) (b ((pro env) b)))
                         (if (and (quote? a) (quote? b))
                             `(quote ,((eval prim) (cadr a) (cadr b)))
                             `(,prim ,a ,b))))
        (((lambda ,x* ,body) . ,e*)
         ((pro env) (Let x* e* body)))
        (else (map (pro env) exp)))))
  ((pro '()) x))
(define (remove-anonymous-lambda x)
  (define (remove exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(remove q) ,(remove a) ,(remove e)))
      ((begin . ,exps) (cons 'begin (map remove exps)))
      ((lambda ,x* ,body) (let ((t (unique-symbol 't)))
                            `(letrec ((,t (lambda ,x* ,(remove body)))) ,t)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body)))
                               (else (remove e)))) e*))
                  (body (remove body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body) `(lambda ,x* ,(remove body))))) e*))
                  (body (remove body)))
              (Letrec x* e* body)))))
      (else (map remove exp))))
  (remove x))
(define (sanitize-binding-forms x)
  (define (Let x* e* body)
    (if (null? x*)
        body
        (list 'let (map (lambda (x e) (cons x (cons e '()))) x* e*) body)))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        (list 'letrec (map (lambda (x e) (cons x (cons e '()))) x* e*) body)))
  (define (sanitize exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(sanitize q) ,(sanitize a) ,(sanitize e)))
      ((begin . ,exps) (make-begin (map sanitize exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(sanitize body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (let loop ((x* x*) (e* e*) (xo* '()) (eo* '()) (xl* '()) (el* '()))
                (if (null? x*)
                    (Letrec xl* el* (Let xo* eo* body))
                    (let ((x (car x*)) (x* (cdr x*)) (e (car e*)) (e* (cdr e*)))
                      (if (and (pair? e) (eq? (car e) 'lambda))
                          (loop x* e* xo* eo* (cons x xl*) (cons e el*))
                          (loop x* e* (cons x xo*) (cons e eo*) xl* el*)))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map sanitize e*))
                  (body (sanitize body)))
              (Letrec x* e* body)))))
      (else (map sanitize exp))))
  (sanitize x))
(define (uncover-free x)
  (define (uncover-exps exps)
    (if (null? exps)
        (values '() '())
        (let-values (((a f*0) (uncover (car exps)))
                     ((d f*1) (uncover-exps (cdr exps))))
          (values (cons a d) (U f*0 f*1)))))
  (define (uncover exp)
    (match exp
      ((quote ,i) (values exp '()))
      (,x (guard (symbol? x)) (values x (if (prim? x) '() (list x))))
      ((if ,q ,a ,e) (let-values (((q f*0) (uncover q))
                                  ((a f*1) (uncover a))
                                  ((e f*2) (uncover e)))
                       (values `(if ,q ,a ,e) (U f*0 (U f*1 f*2)))))
      ((begin . ,exps) (let-values (((exps f*) (uncover-exps exps)))
                         (values (cons 'begin exps) f*)))
      ((lambda ,x* ,body) (let-values (((body f*) (uncover body)))
                            (let ((f* (D f* x*)))
                              (values `(lambda ,x* (free ,f* ,body)) f*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* f*0) (uncover-exps e*))
                         ((body f*1) (uncover body)))
              (values (Let x* e* body) (U f*0 (D f*1 x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* f*0) (uncover-exps e*))
                         ((body f*1) (uncover body)))
              (values (Letrec x* e* body) (D (U f*0 f*1) x*))))))
      (else (uncover-exps exp))))
  (let-values (((x f*) (uncover x)))
    (if (null? f*)
        x
        (error 'uncover-free "uncaptured free variables ~s" f*))))
(define (convert-closures x)
  (define (make-label x)
    (unique-label (extract-root x)))
  (define (make-cp x)
    (unique-symbol 'cp))
  (define (lookup x cp f*)
    (let loop ((f* f*) (i 0))
      (cond ((null? f*) x)
            ((eq? x (car f*)) `(closure-ref ,cp (quote ,i)))
            (else (loop (cdr f*) (+ i 1))))))
  (define (make-set!s x f*)
    (let loop ((f* f*) (i 0) (result '()))
      (if (null? f*)
          (reverse result)
          (loop (cdr f*)
                (+ i 1)
                (cons `(closure-set! ,x (quote ,i) ,(car f*)) result)))))
  (define (make-closure-binding x l f*)
    (list x `(make-closure ,l (quote ,(length f*)))))
  (define (convert cp f* env)
    (lambda (exp)
      (match exp
        ((quote ,i) exp)
        (,x (guard (symbol? x)) (lookup x cp f*))
        ((if ,q ,a ,e) (let ((q ((convert cp f* env) q))
                             (a ((convert cp f* env) a))
                             (e ((convert cp f* env) e)))
                         `(if ,q ,a ,e)))
        ((begin . ,exps) (cons 'begin (map (convert cp f* env) exps)))
        ((let ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert cp f* env) e*))
                    (body ((convert cp f* env) body)))
                (Let x* e* body)))))
        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((l* (map make-label x*))
                    (cp* (map make-cp x*))
                    (f** (map (lambda (e)
                                (match e
                                  ((lambda ,x* (free ,f* ,body)) f*))) e*)))
                (let ((env (append (map cons x* l*) env)))
                  (let ((e* (map (lambda (e cp)
                                   (match e
                                     ((lambda ,x* (free ,f* ,body))
                                      (let ((body ((convert cp f* env) body)))
                                        `(lambda ,(cons cp x*) ,body))))) e* cp*))
                        (set!s (apply append
                                      (map make-set!s
                                           x*
                                           (map (lambda (f*^)
                                                  (map (lambda (f)
                                                         (lookup f cp f*)) f*^)) f**))))
                        (closure-bindings (map make-closure-binding x* l* f**))
                        (body ((convert cp f* env) body)))
                    (Letrec l* e* (list 'let closure-bindings
                                        (make-begin (list (cons 'begin set!s) body))))))))))
        ((,rator . ,rands)
         (let ((rands (map (convert cp f* env) rands)))
           (if (symbol? rator)
               (if (prim? rator)
                   (cons rator rands)
                   (let ((rator (lookup rator cp f*)))
                     (let ((p (assq rator env)))
                       (if p
                           (let ((label (cdr p)))
                             (cons label (cons rator rands)))
                           (cons `(closure-label ,rator)
                                 (cons rator rands))))))
               (let ((t (unique-symbol 't)))
                 (let ((rator ((convert cp f* env) rator)))
                   `(let ((,t ,rator))
                      ((closure-label ,t) ,t . ,rands))))))))))
  ((convert #f '() '()) x))
(define (lift-letrec x)
  (define bindings '())
  (define (lift exp)
    (match exp
      ((quote ,d) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(lift q) ,(lift a) ,(lift e)))
      ((begin . ,exps) (cons 'begin (map lift exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(lift body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map lift e*))
                  (body (lift body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (l* e*)
            (let ((e* (map lift e*))
                  (body (lift body)))
              (set! bindings (append (map list l* e*) bindings))
              body))))
      (else (map lift exp))))
  (let ((x (lift x)))
    `(letrec ,bindings ,x)))
(define (normalize-context x)
  (define value-prims
    '(+ - * cons car cdr make-vector vector-length vector-ref
        box unbox make-closure closure-label closure-ref void))
  (define pred-prims
    '(= < > <= >= eq? null? boolean? fixnum? pair? vector?
        box? procedure?))
  (define effect-prims
    '(set-car! set-cdr! vector-set! set-box! closure-set!))
  (define (value-prim? x)
    (memq x value-prims))
  (define (pred-prim? x)
    (memq x pred-prims))
  (define (effect-prim? x)
    (memq x effect-prims))
  (define (Value exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) (let ((q (Pred q))
                           (a (Value a))
                           (e (Value e)))
                       `(if ,q ,a ,e)))
      ((begin . ,exps)
       (let ((but-last (but-last exps))
             (last (last exps)))
         (let ((but-last (map Effect but-last))
               (last (Value last)))
           (make-nopless-begin (list (cons 'begin but-last) last)))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map Value e*))
                  (body (Value body)))
              (Let x* e* body)))))
      ((,prim . ,rands)
       (guard (value-prim? prim))
       (let ((rands (map Value rands)))
         (cons prim rands)))
      ((,prim . ,rands)
       (guard (pred-prim? prim))
       (let ((rands (map Value rands)))
         `(if ,(cons prim rands) '#t '#f)))
      ((,prim . ,rands)
       (guard (effect-prim? prim))
       (let ((rands (map Value rands)))
         `(begin ,(cons prim rands) (void))))
      (else (map Value exp))))
  (define (Pred exp)
    (match exp
      ((quote ,i) (if (eq? i #f) '(false) '(true)))
      (,x (guard (symbol? x)) `(eq? ,x '#f))
      ((if ,q ,a ,e) (let ((q (Pred q))
                           (a (Pred a))
                           (e (Pred e)))
                       `(if ,q ,a ,e)))
      ((begin . ,exps)
       (let ((but-last (but-last exps))
             (last (last exps)))
         (let ((but-last (map Effect but-last))
               (last (Pred last)))
           (make-nopless-begin (list (cons 'begin but-last) last)))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map Value e*))
                  (body (Pred body)))
              (Let x* e* body)))))
      ((,prim . ,rands)
       (guard (value-prim? prim))
       (let ((rands (map Value rands)))
         `(if (eq? ,(cons prim rands) '#f) (false) (true))))
      ((,prim . ,rands)
       (guard (pred-prim? prim))
       (let ((rands (map Value rands)))
         (cons prim rands)))
      ((,prim . ,rands)
       (guard (effect-prim? prim))
       (let ((rands (map Value rands)))
         `(begin ,(cons prim rands) (true))))
      (else (let ((exp (map Value exp)))
              `(if (eq? ,exp '#f) (false) (true))))))
  (define (Effect exp)
    (match exp
      ((quote ,i) '(nop))
      (,x (guard (symbol? x)) '(nop))
      ((if ,q ,a ,e) (let ((q (Pred q))
                           (a (Effect a))
                           (e (Effect e)))
                       `(if ,q ,a ,e)))
      ((begin . ,exps)
       (let ((exps (map Effect exps)))
         (make-nopless-begin exps)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map Value e*))
                  (body (Effect body)))
              (Let x* e* body)))))
      ((,prim . ,rands)
       (guard (value-prim? prim))
       (let ((rands (map Effect rands)))
         (make-nopless-begin rands)))
      ((,prim . ,rands)
       (guard (pred-prim? prim))
       (let ((rands (map Effect rands)))
         (make-nopless-begin rands)))
      ((,prim . ,rands)
       (guard (effect-prim? prim))
       (let ((rands (map Value rands)))
         (cons prim rands)))
      (else (map Value exp))))
  (match x
    ((letrec ,bds ,body)
     (: bds
        (lambda (l* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body) `(lambda ,x* ,(Value body))))) e*))
                (body (Value body)))
            (Letrec l* e* body)))))))

(define fixnum-tag #b000)
(define fixnum-mask #b111)
(define fixnum-shift 3)

(define pair-tag #b001)
(define pair-mask #b111)
(define pair-size 16)
(define car-disp 0)
(define cdr-disp 8)
(define car-offset (- car-disp pair-tag))
(define cdr-offset (- cdr-disp pair-tag))

(define boolean-tag #b00000110)
(define boolean-mask #b11110111)

(define $false #b00000110)
(define $true #b00001110)
(define $nil #b00010110)
(define $void #b00011110)

(define (specify-representation x)
  (define (specify exp)
    (match exp
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e) `(if ,(specify q)
                          ,(specify a)
                          ,(specify e)))
      ((begin . ,exps) (cons 'begin (map specify exps)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map specify e*))
                  (body (specify body)))
              (Let x* e* body)))))
      ((quote ,i) (cond ((null? i) $nil)
                        ((eq? i #t) $true)
                        ((eq? i #f) $false)
                        (else (ash i fixnum-shift))))
      ((,prim ,a)
       (guard (memq prim '(car cdr)))
       (case prim
         ((car) `(mref ,a ,car-offset))
         ((cdr) `(mref ,a ,cdr-offset))))
      ((,prim ,a ,b)
       (guard (memq prim '(eq? + - * = < > <= >= cons)))
       (let ((a (specify a)) (b (specify b)))
         (case prim
           ((eq?) `(= ,a ,b))
           ((+ - = < > <= >=) `(,prim ,a ,b))
           ((*) (cond ((number? a) `(* ,(sra a fixnum-shift) ,b))
                      ((number? b) `(* ,a ,(sra b fixnum-shift)))
                      (else `(* ,a (sra ,b ,fixnum-shift)))))
           ((cons) (let ((tmp-car (unique-symbol 't))
                         (tmp-cdr (unique-symbol 't))
                         (tmp (unique-symbol 't)))
                     `(let ((,tmp (+ (alloc ,pair-size) ,pair-tag)))
                        (let ((,tmp-car ,a)
                              (,tmp-cdr ,b))
                          (begin
                            (mset! ,tmp ,car-offset ,tmp-car)
                            (mset! ,tmp ,cdr-offset ,tmp-cdr)
                            ,tmp))))))))
      ((void) $void)
      (else (map specify exp))))
  (match x
    ((letrec ,bds ,body)
     (: bds
        (lambda (l* e*)
          (let ((e* (map (lambda (e)
                           (match e
                             ((lambda ,x* ,body)
                              `(lambda ,x* ,(specify body))))) e*))
                (body (specify body)))
            (Letrec l* e* body)))))))
(define test
  (compose pretty-print
           specify-representation
           normalize-context
           lift-letrec
           convert-closures
           uncover-free
           sanitize-binding-forms
           remove-anonymous-lambda
           propagate-constant
           convert-assignments
           purify-letrec
           uncover-assigned
           convert-complex-datum
           parse-scheme))
(define test-code
  '((let ((n 0))
      (letrec ((even? (lambda ()
                        (if (= n 0)
                            #t
                            (begin (set! n (- n 1))
                                   (odd?)))))
               (odd? (lambda ()
                       (if (= n 0)
                           #f
                           (begin (set! n (- n 1))
                                  (even?))))))
        (set! n 88)
        (even?)))
    (letrec ((even? (lambda (n)
                      (if (= n 0)
                          #t
                          (odd? (- n 1)))))
             (odd? (lambda (n)
                     (if (= n 0)
                         #f
                         (even? (- n 1))))))
      (even? 88))
    (((lambda (h)
        ((lambda (f) (f f))
         (lambda (g)
           (h (lambda (x) ((g g) x))))))
      (lambda (fact)
        (lambda (n)
          (if (= n 0)
              1
              (* n (fact (- n 1))))))) 10)
    (let ((compose (lambda (f g)
                     (lambda (x)
                       (f (g x)))))
          (square (lambda (x) (* x x)))
          (double (lambda (x) (* 2 x))))
      ((compose square double) 10))
    (letrec ((map (lambda (proc lst)
                    (if (null? lst)
                        '()
                        (cons (proc (car lst))
                              (map proc (cdr lst))))))
             (filter (lambda (pred lst)
                       (if (null? lst)
                           '()
                           (if (pred (car lst))
                               (cons (car lst)
                                     (filter pred (cdr lst)))
                               (filter pred (cdr lst)))))))
      (map (lambda (x) (* x x))
           (filter (lambda (x) (< x 3)) '(1 2 3 4 5))))))
(define (test-all)
  (for-each test test-code))
